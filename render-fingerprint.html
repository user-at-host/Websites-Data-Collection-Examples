<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Render Fingerprint</title>
    <style>
        body { font-family: sans-serif; background-color: #1e1e1e; color: #d4d4d4; padding: 2em; }
        #container { background-color: #252526; border: 1px solid #333; padding: 1em; border-radius: 5px; }
        canvas { background-color: #555; border-radius: 4px; }
        pre { word-wrap: break-word; white-space: pre-wrap; color: #9cdcfe; }
    </style>
</head>
<body>
    <h1>WebGL Render Fingerprint</h1>
    <div id="container">
        <h2>Rendered Image:</h2>
        <div id="gl-image-src"></div>
        
        <h2>Image Hash (Fingerprint):</h2>
        <pre id="gl-image-hash"></pre>
    </div>

    <script>
        // This is not a real md5 algorithm. It is here just for a demo.
        function md5(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash |= 0;
            }
            return 'md5-hash: ' + hash.toString(16);
        }
        const _el = (selector) => document.querySelector(selector);

        const h = _el("#gl-image-src");
        const f = _el("#gl-image-hash");

        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 128;
        const p = canvas.getContext("webgl2") || canvas.getContext("webgl");

        if (p) {
            try {
                p.viewport(0, 0, p.drawingBufferWidth, p.drawingBufferHeight);
                const m = p.createProgram();
                const x = p.createShader(p.VERTEX_SHADER);
                p.shaderSource(x, "attribute vec2 attrVertex;attribute vec4 attrColor;varying vec4 varyinColor;uniform mat4 transform;void main(){varyinColor=attrColor;gl_Position=transform*vec4(attrVertex,0,1);}");
                p.compileShader(x);
                p.attachShader(m, x);
                
                const v = p.createShader(p.FRAGMENT_SHADER);
                p.shaderSource(v, "precision mediump float;varying vec4 varyinColor;void main(){gl_FragColor=varyinColor;}");
                p.compileShader(v);
                p.attachShader(m, v);

                p.linkProgram(m);
                p.useProgram(m);

                m.vertexPosAttrib = p.getAttribLocation(m, "attrVertex");
                m.colorAttrib = p.getAttribLocation(m, "attrColor");
                p.enableVertexAttribArray(m.vertexPosAttrib);
                p.enableVertexAttribArray(m.colorAttrib);

                m.transform = p.getUniformLocation(m, "transform");
                p.uniformMatrix4fv(m.transform, false, [1.5, 0, 0, 0, 0, 1.5, 0, 0, 0, 0, 1, 0, 0.5, 0, 0, 1]);

                const b = [];
                const S = 128;
                for (let C = 0; C < S; C++) {
                    const L = (45 + C / S * 270) / 360 * 2 * Math.PI;
                    const R = (45 + (C + 1) / S * 270) / 360 * 2 * Math.PI;
                    b.push(-.25, 0, 1, .7, 0, 1);
                    b.push(-.25 + .5 * Math.cos(L), .5 * Math.sin(L), 2, 1 - C / S, 0, 1);
                    b.push(-.25 + .5 * Math.cos(R), .5 * Math.sin(R), 1, 1 - (C + 1) / S, 0, 1);
                }
                const T = new Float32Array(b);
                const w = p.createBuffer();
                p.bindBuffer(p.ARRAY_BUFFER, w);
                p.bufferData(p.ARRAY_BUFFER, T, p.STATIC_DRAW);
                p.vertexAttribPointer(m.vertexPosAttrib, 2, p.FLOAT, !1, 24, 0);
                p.vertexAttribPointer(m.colorAttrib, 4, p.FLOAT, !1, 24, 8);
                
                p.drawArrays(p.TRIANGLES, 0, T.length / 6);
                
                h.appendChild(p.canvas);

            } catch (e) {
                h.textContent = e;
            }

            try {
                const M = new Uint8Array(p.canvas.width * p.canvas.height * 4);
                p.readPixels(0, 0, p.canvas.width, p.canvas.height, p.RGBA, p.UNSIGNED_BYTE, M);
                const y = JSON.stringify(M).replace(/,?"[0-9]+":/g, "");
                f.textContent = md5(y);

            } catch (e) {
                f.textContent = "Error reading pixels: " + e;
            }
        } else {
            h.textContent = "WebGL not supported.";
        }
    </script>
</body>
</html>
